# 目标文件名和源文件路径定义
BOOT_TARGET   = boot
SETUP_TARGET  = setup

BOOT_SRC      = ./boot/$(BOOT_TARGET).asm
SETUP_SRC     = ./boot/$(SETUP_TARGET).asm
KERNEL_SRC    = ./boot/head.asm

BUILDPATH     = ./build


# 输出文件定义
BOOT_BIN      = $(BUILDPATH)/$(BOOT_TARGET).bin
SETUP_BIN     = $(BUILDPATH)/$(SETUP_TARGET).bin
SYSTEM_BIN    = $(BUILDPATH)/system.bin
KERNEL_O      = $(BUILDPATH)/kernel.o
KERNEL_BIN    = $(BUILDPATH)/kernel.bin
DISK_IMG      = $(BUILDPATH)/disk.img  # 统一的磁盘镜像文件名


# 工具定义
NASM          = nasm
QEMU          = qemu-system-i386
DD            = dd


# 编译选项
CFLAGS:= -m32 # 32 位的程序
CFLAGS+= -masm=intel
CFLAGS+= -fno-builtin	# 不需要 gcc 内置函数
CFLAGS+= -nostdinc		# 不需要标准头文件
CFLAGS+= -fno-pic		# 不需要位置无关的代码  position independent code
CFLAGS+= -fno-pie		# 不需要位置无关的可执行程序 position independent executable
CFLAGS+= -nostdlib		# 不需要标准库
CFLAGS+= -fno-stack-protector	# 不需要栈保护
CFLAGS:=$(strip ${CFLAGS})

DEBUG:= -g


# 主要目标
all: run

# 目录创建
$(BUILDPATH):
	mkdir -p $(BUILDPATH)
	@echo "创建build目录: $(BUILDPATH)"


# 汇编目标
$(BOOT_BIN): $(BOOT_SRC) | $(BUILDPATH)
	$(NASM) -f bin $(BOOT_SRC) -o $(BOOT_BIN)
	@echo "引导程序汇编完成: $(BOOT_BIN)"

$(SETUP_BIN): $(SETUP_SRC) | $(BUILDPATH)
	$(NASM) -f bin $(SETUP_SRC) -o $(SETUP_BIN)
	@echo "Setup程序汇编完成: $(SETUP_BIN)"

$(KERNEL_O): $(KERNEL_SRC)  | $(BUILDPATH)
	$(NASM)  -f elf32 -g  $(KERNEL_SRC) -o $(KERNEL_O)
	@echo "KERNEL_O程序汇编完成: $(KERNEL_O)"



# 内核编译
$(KERNEL_BIN): $(KERNEL_O) ${BUILDPATH}/init/main.o ${BUILDPATH}/kernel/chr_drv/console.o ${BUILDPATH}/kernel/chr_drv/easy_keybord.o ${BUILDPATH}/kernel/chr_drv/clock.o\
	${BUILDPATH}/kernel/printk.o  ${BUILDPATH}/kernel/asm/io.o ${BUILDPATH}/kernel/asm/interrupt_handler.o ${BUILDPATH}/kernel/asm/clock_interrupt_handler.o\
	${BUILDPATH}/kernel/vfprintf.o ${BUILDPATH}/kernel/gdt.o ${BUILDPATH}/kernel/idt.o ${BUILDPATH}/kernel/traps.o\
	${BUILDPATH}/mm/memory.o\
	${BUILDPATH}/lib/string.o  ${BUILDPATH}/lib/stdio.o  ${BUILDPATH}/lib/stdlib.o ${BUILDPATH}/lib/unistd.o ${BUILDPATH}/lib/write.o  ${BUILDPATH}/lib/error.o        | $(BUILDPATH)
	ld -m elf_i386 -g $^ -o $(KERNEL_BIN) -Ttext 0x1200


${BUILDPATH}/kernel/chr_drv/%.o:./kernel/chr_drv/%.c
	mkdir -p ${BUILDPATH}/kernel/chr_drv
	gcc ${CFLAGS} ${DEBUG} -c $< -o $@

${BUILDPATH}/kernel/%.o:./kernel/%.c
	mkdir -p ${BUILDPATH}/kernel
	gcc ${CFLAGS} ${DEBUG} -c $< -o $@

${BUILDPATH}/kernel/asm/io.o: ./kernel/asm/io.asm | $(BUILDPATH)
	mkdir -p ${BUILDPATH}/kernel/asm
	$(NASM) -f elf32 -g $< -o $@

${BUILDPATH}/kernel/asm/interrupt_handler.o: ./kernel/asm/interrupt_handler.asm | $(BUILDPATH)
	mkdir -p ${BUILDPATH}/kernel/asm
	$(NASM) -f elf32 -g $< -o $@

${BUILDPATH}/kernel/asm/clock_interrupt_handler.o: ./kernel/asm/clock_interrupt_handler.asm | $(BUILDPATH)
	mkdir -p ${BUILDPATH}/kernel/asm
	$(NASM) -f elf32 -g $< -o $@

#${BUILDPATH}/kernel/chr_drv/%.o: ./kernel/chr_drv/%.c
#
#

${BUILDPATH}/lib/%.o: ./lib/%.c
	mkdir -p ${BUILDPATH}/lib
	gcc ${CFLAGS} -g -c $< -o $@

${BUILDPATH}/mm/%.o:./mm/%.c
	mkdir -p ${BUILDPATH}/mm
	gcc ${CFLAGS} ${DEBUG} -c $< -o $@

${BUILDPATH}/init/main.o: ./init/main.c
	mkdir -p ${BUILDPATH}/init/
	gcc ${CFLAGS} -g -c $< -o $@


# 系统二进制文件 将仅代码 拷贝到SYSTEM_BIN
$(SYSTEM_BIN): $(KERNEL_BIN) | $(BUILDPATH)
	objcopy -O binary $(KERNEL_BIN) $(SYSTEM_BIN)
	nm $(KERNEL_BIN) | sort > ${BUILDPATH}/system.map


# 磁盘镜像生成
$(DISK_IMG): $(BOOT_BIN) $(SETUP_BIN) $(SYSTEM_BIN)
	$(shell rm -rf $(DISK_IMG))
	# 创建16MB磁盘镜像
	bximage -q -hd=64 -func=create -sectsize=512 -imgmode=flat $(DISK_IMG)
	# 写入引导扇区(第一个扇区)
	$(DD) if=$(BOOT_BIN) of=$(DISK_IMG) bs=512 seek=0 count=1 conv=notrunc
	# 写入setup程序(第二个扇区)
	$(DD) if=$(SETUP_BIN) of=$(DISK_IMG) bs=512 seek=1 count=2 conv=notrunc
	# 写入内核
	$(DD) if=$(SYSTEM_BIN) of=$(DISK_IMG) bs=512 seek=3 count=60 conv=notrunc
	@echo "磁盘镜像创建完成: $(DISK_IMG)"


# 运行目标
LOCK_FILE := $(BUILDPATH)/disk.img.lock # 锁文件路径（自动关联镜像名）

run_qemug:clean $(DISK_IMG)
	$(QEMU) \
    	-m 128M \
    	-boot c \
    	-hda $(DISK_IMG) \
    	-s -S

run_qume:clean $(DISK_IMG)
# 检测锁文件是否存在，存在则删除（-f 确保不存在时不报错）
	@if [ -f $(LOCK_FILE) ]; then \
		echo "删除残留锁文件: $(LOCK_FILE)"; \
		rm -f $(LOCK_FILE); \
	else \
		echo "未发现锁文件，无需删除"; \
	fi
	@echo "启动QEMU模拟器..."
	$(QEMU) -m 64M -hda $(DISK_IMG)  -net nic,model=ne2k_pci  # 使用硬盘模式

run_bochs: clean $(DISK_IMG)
# 检测锁文件是否存在，存在则删除（-f 确保不存在时不报错）
	@if [ -f $(LOCK_FILE) ]; then \
		echo "删除残留锁文件: $(LOCK_FILE)"; \
		rm -f $(LOCK_FILE); \
	else \
		echo "未发现锁文件，无需删除"; \
	fi

	@echo "启动bochs模拟器..."
	~/apps/bochs-2.7/bochs -q -f boch.config  # 使用硬盘模式

run_bochs_ng: clean $(DISK_IMG)
# 检测锁文件是否存在，存在则删除（-f 确保不存在时不报错）
	@if [ -f $(LOCK_FILE) ]; then \
		echo "删除残留锁文件: $(LOCK_FILE)"; \
		rm -f $(LOCK_FILE); \
	else \
		echo "未发现锁文件，无需删除"; \
	fi

	@echo "启动bochs模拟器..."
	~/bochs/bin/bochs -q -f bochng.config  # 使用硬盘模式

# 单独编译目标
boot: $(BOOT_BIN)
setup: $(SETUP_BIN)


# 清理目标
clean:
	rm -rf $(BUILDPATH)
	@echo "清理完成"


# 生成的内核镜像给VBox、VMware用
vmdk: $(BUILDPATH)/master.vmdk

$(BUILDPATH)/master.vmdk: ./build/disk.img
	qemu-img convert -O vmdk $< $@
# 伪目标声明
.PHONY: all run clean boot setup