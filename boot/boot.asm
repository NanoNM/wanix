; ==============================================================================
; boot.asm - 16位实模式引导程序（MBR 主引导记录）
; 功能：1. 初始化视频模式 2. 读取 setup 程序到内存 3. 跳转到 setup 执行
; 加载地址：BIOS 固定加载 MBR 到 0x7C00
; 引导标识：结尾必须包含 0xAA55（512字节扇区的最后2字节）
; ==============================================================================
[ORG 0x7C00]   ; 程序被 BIOS 加载到内存 0x7C00 处
[BITS 16]      ; 明确指定 16位实模式（实模式下默认）

; ==============================================================================
; 代码段：引导程序核心逻辑
; ==============================================================================
_start:
    ; 步骤1：初始化视频模式（3号模式 = 80x25 文本模式，清屏并重置光标）
    mov ax, 3        ; AH=0（设置模式），AL=3（文本模式）
    int 0x10         ; 调用 BIOS 0x10 中断（视频服务）

    ; 步骤2：打印引导信息（提示正在加载 setup 程序）
    mov si, MSG_LOAD ; SI 指向字符串首地址（DS:SI 寻址）
    call .print_str  ; 调用字符串打印函数

    ; 步骤3：配置硬盘读取参数（读取 setup 程序到内存）
    mov ecx, 1       ; ECX = LBA 扇区号（setup 程序存放在第1扇区，从0开始计数）
    mov bl, 1        ; BL = 读取扇区数（setup 程序占1个扇区，512字节）
    call .lba_read   ; 调用 LBA 模式读硬盘函数（读取到 0x5C00）

    ; 步骤4：跳转到 setup 程序执行（setup 已加载到 0x5C00）
    jmp 0x5C00       ; 远跳（实模式下直接跳转到物理地址 0x5C00）


; ==============================================================================
; 子函数1：LBA 模式读取硬盘扇区（实模式 IDE 硬盘访问）
; 功能：从指定 LBA 扇区读取指定数量的扇区，写入到内存 0x5C00
; 输入：ECX = LBA 扇区号（28位 LBA，支持最大 128GB 硬盘）
;       BL  = 读取扇区数（此处固定为1，对应 setup 程序大小）
; 输出：扇区数据写入到内存 0x5C00 起始地址
; ==============================================================================
.lba_read:
    pusha            ; 保存所有通用寄存器（AX/BX/CX/DX/SI/DI/BP/SP），避免破坏主程序状态

    ; --------------------------
    ; 1. 写入扇区计数（IDE 端口 0x1F2）
    ; --------------------------
    mov dx, 0x1F2    ; 0x1F2 = 扇区计数寄存器（指定要读取的扇区数量）
    mov al, bl       ; AL = 读取扇区数（BL 传入，此处为1）
    out dx, al       ; 输出到端口（告知硬盘要读多少个扇区）

    ; --------------------------
    ; 2. 写入 LBA 地址（28位，分4个端口写入）
    ; --------------------------
    ; LBA [7:0]（低8位）→ 端口 0x1F3
    inc dx           ; dx = 0x1F3（LBA 低8位寄存器）
    mov al, cl       ; AL = LBA 低8位（ECX 的最低字节）
    out dx, al

    ; LBA [15:8]（中8位）→ 端口 0x1F4
    inc dx           ; dx = 0x1F4（LBA 中8位寄存器）
    mov al, ch       ; AL = LBA 中8位（ECX 的次低字节）
    out dx, al

    ; LBA [23:16]（高8位）→ 端口 0x1F5
    inc dx           ; dx = 0x1F5（LBA 高8位寄存器）
    shr ecx, 16      ; ECX 右移16位，提取 LBA [23:16]（高8位）
    mov al, cl       ; AL = LBA 高8位（ECX 右移后的低字节）
    out dx, al

    ; LBA [27:24] + 驱动器选择 → 端口 0x1F6
    inc dx           ; dx = 0x1F6（驱动器/头部寄存器）
    shr ecx, 8       ; ECX 再右移8位，提取 LBA [27:24]（最高4位）
    or al, 0xE0      ; 0xE0 = 11100000B：bit7=1（主盘）、bit6=1（LBA模式）、bit5=1（固定）
    out dx, al       ; 告知硬盘：主盘、LBA模式、LBA 最高4位

    ; --------------------------
    ; 3. 发送读命令（IDE 端口 0x1F7）
    ; --------------------------
    inc dx           ; dx = 0x1F7（命令/状态寄存器）
    mov al, 0x20     ; 0x20 = 读扇区命令（无重试，BIOS 常用命令）
    out dx, al       ; 发送命令，硬盘开始读取

    ; --------------------------
    ; 4. 等待硬盘就绪（轮询状态寄存器）
    ; --------------------------
    call .wait_ready ; 调用等待就绪函数，直到硬盘空闲且数据就绪

    ; --------------------------
    ; 5. 读取数据到内存（0x5C00）
    ; --------------------------
    mov di, 0x5C00   ; DI = 目标内存地址（setup 程序的加载地址）
    mov cx, 512/2 * 1; CX = 读取次数：1个扇区（512字节），每次读2字节（insw）→ 512/2 = 256次
    mov dx, 0x1F0    ; 0x1F0 = 数据端口（双向，硬盘→内存为读）
    rep insw         ; 批量读取：每次从 DX 读2字节到 ES:DI，CX--，直到 CX=0

    popa             ; 恢复所有通用寄存器
    ret              ; 返回主程序


; ==============================================================================
; 子函数2：等待硬盘就绪（辅助 .lba_read 函数）
; 功能：轮询 IDE 状态寄存器，直到硬盘空闲且数据就绪
; 原理：状态寄存器（0x1F7）bit7=1（忙）、bit3=1（数据就绪）
; ==============================================================================
.wait_ready:
    mov dx, 0x1F7    ; dx = 0x1F7（命令/状态寄存器）

.wait_loop:
    in al, dx        ; 读取状态寄存器值到 AL
    test al, 0x80    ; 检查 bit7（忙标志）：1=忙，0=空闲
    jnz .wait_loop   ; 忙 → 继续等待
    test al, 0x08    ; 检查 bit3（数据就绪标志）：1=就绪，0=未就绪
    jz .wait_loop    ; 未就绪 → 继续等待
    ret              ; 就绪 → 返回调用者


; ==============================================================================
; 子函数3：BIOS 字符串打印（实模式视频服务）
; 功能：打印以 NULL（0x00）结尾的字符串到屏幕（80x25 文本模式）
; 输入：SI = 字符串首地址（DS:SI 指向字符串，字符串需以 0 结尾）
; 依赖：BIOS 0x10 中断（AH=0x0E 为 Teletype 输出，光标跟随字符移动）
; ==============================================================================
.print_str:
    mov ah, 0x0E    ; AH = 0x0E（BIOS 0x10 中断的 Teletype 输出功能）
    mov bh, 0x00    ; BH = 0x00（显示页号，默认第0页）
    mov bl, 0x07    ; BL = 0x07（字符颜色：黑底白字，文本模式默认属性）

.print_loop:
    lodsb           ; 从 DS:SI 读取1字节到 AL，同时 SI 自动 +1（指向下一个字符）
    or al, al       ; 检查 AL 是否为 NULL（0x00，字符串结束符）
    jz .print_end   ; 是结束符 → 退出打印
    int 0x10        ; 不是结束符 → 调用 BIOS 0x10 中断，打印当前字符
    jmp .print_loop ; 继续打印下一个字符

.print_end:
    ret              ; 返回主程序


; ==============================================================================
; 数据段：字符串常量 + MBR 引导标识
; ==============================================================================
MSG_LOAD:  db  "Loading setup...", 13, 10, 0  ; 引导提示字符串
; 13 = 回车符（CR），10 = 换行符（LF），0 = 字符串结束符（NULL）

; --------------------------
; MBR 扇区填充与引导标识（必须满足 512 字节）
; --------------------------
times 510 - ($ - $$) db 0  ; 填充 0，使扇区总长度达到 510 字节
dw 0xAA55                  ; MBR 引导标识（最后2字节，BIOS 识别为可引导扇区的标志）